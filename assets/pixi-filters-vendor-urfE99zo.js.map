{"version":3,"file":"pixi-filters-vendor-urfE99zo.js","sources":["../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/defaults/default.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/defaults/default2.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/glow/glow.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/glow/glow2.mjs","../../node_modules/.pnpm/pixi-filters@6.1.4_pixi.js@8.13.2/node_modules/pixi-filters/lib/glow/GlowFilter.mjs"],"sourcesContent":["var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=default.mjs.map\n","var wgslVertex = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\";\n\nexport { wgslVertex as default };\n//# sourceMappingURL=default2.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=kawase-blur.mjs.map\n","var source = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\\n  // Average\\n  color *= 0.25;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=kawase-blur2.mjs.map\n","var fragmentClamp = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputClamp;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragmentClamp as default };\n//# sourceMappingURL=kawase-blur-clamp2.mjs.map\n","var sourceClamp = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Average\\n  color *= 0.25;\\n    \\n  return color;\\n}\";\n\nexport { sourceClamp as default };\n//# sourceMappingURL=kawase-blur-clamp.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './kawase-blur.mjs';\nimport source from './kawase-blur2.mjs';\nimport fragmentClamp from './kawase-blur-clamp2.mjs';\nimport sourceClamp from './kawase-blur-clamp.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _KawaseBlurFilter = class _KawaseBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }\");\n      options = { strength: options };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.clamp = args[2];\n    }\n    options = { ..._KawaseBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: options?.clamp ? sourceClamp : source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: options?.clamp ? fragmentClamp : fragment,\n      name: \"kawase-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        kawaseBlurUniforms: {\n          uOffset: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_pixelSize\", { x: 0, y: 0 });\n    __publicField(this, \"_clamp\");\n    __publicField(this, \"_kernels\", []);\n    __publicField(this, \"_blur\");\n    __publicField(this, \"_quality\");\n    this.uniforms = this.resources.kawaseBlurUniforms.uniforms;\n    this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };\n    if (Array.isArray(options.strength)) {\n      this.kernels = options.strength;\n    } else if (typeof options.strength === \"number\") {\n      this._blur = options.strength;\n      this.quality = options.quality ?? 3;\n    }\n    this._clamp = !!options.clamp;\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const uvX = this.pixelSizeX / input.source.width;\n    const uvY = this.pixelSizeY / input.source.height;\n    let offset;\n    if (this._quality === 1 || this._blur === 0) {\n      offset = this._kernels[0] + 0.5;\n      this.uniforms.uOffset[0] = offset * uvX;\n      this.uniforms.uOffset[1] = offset * uvY;\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const renderTarget = TexturePool.getSameSizeTexture(input);\n      let source2 = input;\n      let target = renderTarget;\n      let tmp;\n      const last = this._quality - 1;\n      for (let i = 0; i < last; i++) {\n        offset = this._kernels[i] + 0.5;\n        this.uniforms.uOffset[0] = offset * uvX;\n        this.uniforms.uOffset[1] = offset * uvY;\n        filterManager.applyFilter(this, source2, target, true);\n        tmp = source2;\n        source2 = target;\n        target = tmp;\n      }\n      offset = this._kernels[last] + 0.5;\n      this.uniforms.uOffset[0] = offset * uvX;\n      this.uniforms.uOffset[1] = offset * uvY;\n      filterManager.applyFilter(this, source2, output, clearMode);\n      TexturePool.returnTexture(renderTarget);\n    }\n  }\n  /**\n    * The amount of blur, value greater than `0`.\n    * @default 4\n    */\n  get strength() {\n    return this._blur;\n  }\n  set strength(value) {\n    this._blur = value;\n    this._generateKernels();\n  }\n  /**\n    * The quality of the filter, integer greater than `1`.\n    * @default 3\n    */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = Math.max(1, Math.round(value));\n    this._generateKernels();\n  }\n  /**\n    * The kernel size of the blur filter, for advanced usage\n    * @default [0]\n    */\n  get kernels() {\n    return this._kernels;\n  }\n  set kernels(value) {\n    if (Array.isArray(value) && value.length > 0) {\n      this._kernels = value;\n      this._quality = value.length;\n      this._blur = Math.max(...value);\n    } else {\n      this._kernels = [0];\n      this._quality = 1;\n    }\n  }\n  /**\n    * The size of the pixels. Large size is blurrier. For advanced usage.\n    * @default {x:1,y:1}\n    */\n  get pixelSize() {\n    return this._pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      this.pixelSizeX = this.pixelSizeY = value;\n      return;\n    }\n    if (Array.isArray(value)) {\n      this.pixelSizeX = value[0];\n      this.pixelSizeY = value[1];\n      return;\n    }\n    this._pixelSize = value;\n  }\n  /**\n    * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.\n    * @default 1\n    */\n  get pixelSizeX() {\n    return this.pixelSize.x;\n  }\n  set pixelSizeX(value) {\n    this.pixelSize.x = value;\n  }\n  /**\n    * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.\n    * @default 1\n    */\n  get pixelSizeY() {\n    return this.pixelSize.y;\n  }\n  set pixelSizeY(value) {\n    this.pixelSize.y = value;\n  }\n  /**\n    * Get the if the filter is clamped\n    * @default false\n    */\n  get clamp() {\n    return this._clamp;\n  }\n  /** Update padding based on kernel data */\n  _updatePadding() {\n    this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n  }\n  /** Auto generate kernels by blur & quality */\n  _generateKernels() {\n    const blur = this._blur;\n    const quality = this._quality;\n    const kernels = [blur];\n    if (blur > 0) {\n      let k = blur;\n      const step = blur / quality;\n      for (let i = 1; i < quality; i++) {\n        k -= step;\n        kernels.push(k);\n      }\n    }\n    this._kernels = kernels;\n    this._updatePadding();\n  }\n};\n/** Default values for options. */\n__publicField(_KawaseBlurFilter, \"DEFAULT_OPTIONS\", {\n  strength: 4,\n  quality: 3,\n  clamp: false,\n  pixelSize: { x: 1, y: 1 }\n});\nlet KawaseBlurFilter = _KawaseBlurFilter;\n\nexport { KawaseBlurFilter };\n//# sourceMappingURL=KawaseBlurFilter.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uStrength;\\nuniform vec3 uColor;\\nuniform float uKnockout;\\nuniform float uAlpha;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159265358979323846264;\\n\\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\\nconst float DIST = __DIST__;\\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\\n\\nvoid main(void) {\\n    vec2 px = vec2(1.) / uInputSize.xy;\\n\\n    float totalAlpha = 0.;\\n\\n    vec2 direction;\\n    vec2 displaced;\\n    vec4 curColor;\\n\\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\\n      direction = vec2(cos(angle), sin(angle)) * px;\\n\\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\\n          curColor = texture(uTexture, displaced);\\n          totalAlpha += (DIST - curDistance) * curColor.a;\\n      }\\n    }\\n    \\n    curColor = texture(uTexture, vTextureCoord);\\n\\n    vec4 glowColor = vec4(uColor, uAlpha);\\n    bool knockout = uKnockout > .5;\\n    float innerStrength = uStrength[0];\\n    float outerStrength = uStrength[1];\\n\\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\\n    float innerGlowStrength = min(1., innerGlowAlpha);\\n    \\n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\\n\\n    if (knockout) {\\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\\n    }\\n    else {\\n      finalColor = innerColor + outerGlowColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glow.mjs.map\n","var source = \"struct GlowUniforms {\\n  uDistance: f32,\\n  uStrength: vec2<f32>,\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uQuality: f32,\\n  uKnockout: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let quality = glowUniforms.uQuality;\\n  let distance = glowUniforms.uDistance;\\n\\n  let dist: f32 = glowUniforms.uDistance;\\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\\n\\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\n  var totalAlpha: f32 = 0.0;\\n\\n  var direction: vec2<f32>;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n      curColor = textureSample(uTexture, uSampler, displaced);\\n      totalAlpha += (dist - curDistance) * curColor.a;\\n    }\\n  }\\n    \\n  curColor = textureSample(uTexture, uSampler, uv);\\n\\n  let glowColorRGB = glowUniforms.uColor;\\n  let glowAlpha = glowUniforms.uAlpha;\\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\\n  let innerStrength = glowUniforms.uStrength[0];\\n  let outerStrength = glowUniforms.uStrength[1];\\n\\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\\n  \\n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\\n  \\n  if (knockout) {\\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\\n  }\\n  else {\\n    return innerColor + outerGlowColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\";\n\nexport { source as default };\n//# sourceMappingURL=glow2.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './glow.mjs';\nimport source from './glow2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GlowFilter = class _GlowFilter extends Filter {\n  /**\n   * @param options - Options for the GlowFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GlowFilter.DEFAULT_OPTIONS, ...options };\n    const distance = options.distance ?? 10;\n    const quality = options.quality ?? 0.1;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / quality / distance).toFixed(7)}`).replace(/__DIST__/gi, `${distance.toFixed(0)}.0`),\n      name: \"glow-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        glowUniforms: {\n          uDistance: { value: distance, type: \"f32\" },\n          uStrength: { value: [options.innerStrength, options.outerStrength], type: \"vec2<f32>\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uQuality: { value: quality, type: \"f32\" },\n          uKnockout: { value: options?.knockout ?? false ? 1 : 0, type: \"f32\" }\n        }\n      },\n      padding: distance\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.glowUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 16777215;\n  }\n  /**\n   * Only draw the glow, not the texture itself\n   * @default false\n   */\n  get distance() {\n    return this.uniforms.uDistance;\n  }\n  set distance(value) {\n    this.uniforms.uDistance = this.padding = value;\n  }\n  /**\n  * The strength of the glow inward from the edge of the sprite.\n  * @default 0\n  */\n  get innerStrength() {\n    return this.uniforms.uStrength[0];\n  }\n  set innerStrength(value) {\n    this.uniforms.uStrength[0] = value;\n  }\n  /**\n  * The strength of the glow outward from the edge of the sprite.\n  * @default 4\n  */\n  get outerStrength() {\n    return this.uniforms.uStrength[1];\n  }\n  set outerStrength(value) {\n    this.uniforms.uStrength[1] = value;\n  }\n  /**\n  * The color of the glow.\n  * @default 0xFFFFFF\n  */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n  * The alpha of the glow\n  * @default 1\n  */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n  * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n  * @default 0.1\n  */\n  get quality() {\n    return this.uniforms.uQuality;\n  }\n  set quality(value) {\n    this.uniforms.uQuality = value;\n  }\n  /**\n  * Only draw the glow, not the texture itself\n  * @default false\n  */\n  get knockout() {\n    return this.uniforms.uKnockout === 1;\n  }\n  set knockout(value) {\n    this.uniforms.uKnockout = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_GlowFilter, \"DEFAULT_OPTIONS\", {\n  distance: 10,\n  outerStrength: 4,\n  innerStrength: 0,\n  color: 16777215,\n  alpha: 1,\n  quality: 0.1,\n  knockout: false\n});\nlet GlowFilter = _GlowFilter;\n\nexport { GlowFilter };\n//# sourceMappingURL=GlowFilter.mjs.map\n"],"names":["fragment","source","__defProp","__defNormalProp","__publicField","_KawaseBlurFilter","_GlowFilter"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}